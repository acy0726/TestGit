<!doctype html>
<html>
<head>
    <title>TF.js Test</title>
    <!-- 
    <script src="tf-layers.js"></script>
    <script src="tf-core.js"></script>
    <script src="tf.js"></script>
    -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"></script>
    <script type="text/javascript">
    
    
	    const DB_NAME = 'MyTestDatabase';
	    const DB_VERSION =3; // Use a long long for this value (don't use a float)
	    const DB_STORE_NAME = 'tables';
	    var db;
	    var request = indexedDB.open(DB_NAME,DB_VERSION);
	    
	    request.onerror = function(event) {
	      alert("erorr database");
	    };
	    request.onsuccess = function(event) {
	    	db = request.result;
	        console.log("openDb DONE");
	    };
	    
	    
	    request.onupgradeneeded = function(event) { 
	   	  // Save the IDBDatabase interface 
	   	  
	   	  db = event.target.result;
	   	  // Create an objectStore for this database
	   	  var objectStore = db.createObjectStore(DB_STORE_NAME, { keyPath: 'id', autoIncrement: true });
	      objectStore.createIndex("times", "times", { unique: false });
	      objectStore.createIndex("category", "category", { unique: false });
	      objectStore.createIndex("etc", "etc", { unique: false });
	   	};
	    
	   	
	   	function getObjectStore(store_name, mode) {
	   	    var tx = db.transaction(store_name, mode);
	   	    return tx.objectStore(store_name);
	   	}
	    
	   	function adds(){
	   		
	   		var category = document.getElementById('category').value;
	   		
	   		var dt = new Date();
	   		
	   		var times = parseInt(dt.getHours())*60*60
	   		times = times + parseInt(dt.getMinutes())*60
	   		times = times + parseInt(dt.getSeconds())
	   		
	   		
	   		
		    var store = getObjectStore(DB_STORE_NAME,'readwrite');
		    
		    req = store.add({times:times,category:category,etc:'00'});
		    
		    req.onsuccess = function (evt) {
		        console.log("Insertion in DB successful");
		      };
		      req.onerror = function() {
		        console.error("addPublication error", this.error);
		        displayActionFailure(this.error);
		      };
	   	}
	   	
	   	
	   	function lists(){
	   		store = getObjectStore(DB_STORE_NAME, 'readonly');
	   		//req = store.count();
	   		timeArray = new Array; 	
	   	    categoryArray = new Array;
	   		req = store.openCursor();
	   		
	   		var i = 0;
	   	    req.onsuccess = function(evt) {
	   	    	
	   	      var cursor = evt.target.result;
	   	      
	   	      // If the cursor is pointing at something, ask for the data
	   	      if (cursor) {
	   	        console.log("displayPubList cursor:", cursor);
	   	        req = store.get(cursor.key);
	   	        req.onsuccess = function (evt) {
	   	          var value = evt.target.result;
		   	       console.log("times :", value.times);
		   	  	   console.log("category :", value.category);
		   	  		console.log("etc :", value.etc);
		   	  	timeArray.push(value.times);
		  	 	 categoryArray.push(value.category);
		   	  		
	   	        };
	   	        // Move on to the next object in store
	   	        cursor.continue();
	   	        // This counter serves only to create distinct ids
	   	   
	   	        
	   	      } else {
	   	       	alert(timeArray);
	   	     	alert(categoryArray);
	   	      }
	   	    
	   	      
	   	    };
	   		
	   	}
	   	
	   	
	   	
	   	function tensorSetting(){
	   		
	   		
	   	}
	   	
	   	function clearObjectStore() {
	   	    var store = getObjectStore(DB_STORE_NAME, 'readwrite');
	   	    var req = store.clear();
	   	    req.onsuccess = function(evt) {
	   	      displayActionSuccess("Store cleared");
	   	      
	   	    };
	   	    req.onerror = function (evt) {
	   	      console.error("clearObjectStore:", evt.target.errorCode);
	   	   
	   	    };
	   	  }
	   	
            
	   	async function initTF() {
	   		const model = tf.sequential();
	   		 model.add(tf.layers.dense({units: 10, batchInputShape: [null ,1]}));
		   	 model.add(tf.layers.dense({units: 10, activation: 'relu'}));
		   	 model.add(tf.layers.dense({units: 10, activation: 'softmax'}));
				

		   	model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});
		   	
		   	const history = await model.fit(
		   			tf.ones([50, 1]), tf.ones([50, 10]), {
		   	  batchSize: 1,
		   	  epochs: 1
		   	});
		   	
		   	model.predict(tf.randomNormal([10, 1])).print();
		   	 
	   	}
        
    </script>
</head>
<body>
 	<select id="category">
		<option value='1'>news</option>
		<option value='2'>shopping</option>
		<option value='3'>study</option>
		<option value='4'>sports</option>
		<option value='5'>job</option>
		<option value='6'>movie</option>
		<option value='7'>fishing</option>
		<option value='8'>food</option>
		<option value='9'>travel</option>
		<option value='10'>game</option>
 	</select>
 	
	<input type="text" id="stext" value="" />
	<input type="button" id="search" value="search" onclick="adds()"/>
	<br/>
    <input type="button" id="" value="add" onclick="adds()" />
    <input type="button" id="" value="list" onclick="lists()" />
    <br>
     <input type="button" id="" value="clear" onclick="clearObjectStore()"/>
     
     <input type="button" id="" value="initTF" onclick="initTF()" />
      
     <input type="button" id="" value="politics" />

</html>
