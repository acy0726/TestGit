<!doctype html>
<html>
<head>
    <title>TF.js Test</title>
    <!-- 
    <script src="tf-layers.js"></script>
    <script src="tf-core.js"></script>
    <script src="tf.js"></script>
    -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"></script>
    <script type="text/javascript">
    
    
	    const DB_NAME = 'MyTestDatabase';
	    const DB_VERSION =3; // Use a long long for this value (don't use a float)
	    const DB_STORE_NAME = 'tables';
	    var db;
	    var request = indexedDB.open(DB_NAME,DB_VERSION);
	    
	    request.onerror = function(event) {
	      alert("erorr database");
	    };
	    request.onsuccess = function(event) {
	    	db = request.result;
	        console.log("openDb DONE");
	        lists();
	    };
	    
	    
	    request.onupgradeneeded = function(event) { 
	   	  // Save the IDBDatabase interface 
	   	  
	   	  db = event.target.result;
	   	  // Create an objectStore for this database
	   	  var objectStore = db.createObjectStore(DB_STORE_NAME, { keyPath: 'id', autoIncrement: true });
	      objectStore.createIndex("times", "times", { unique: false });
	      objectStore.createIndex("category", "category", { unique: false });
	      objectStore.createIndex("etc", "etc", { unique: false });
	   	};
	    
	   	
	   	function getObjectStore(store_name, mode) {
	   	    var tx = db.transaction(store_name, mode);
	   	    return tx.objectStore(store_name);
	   	}
	    
	   	
	   	function clearObjectStore() {
	   	    var store = getObjectStore(DB_STORE_NAME, 'readwrite');
	   	    var req = store.clear();
	   	    req.onsuccess = function(evt) {
	   	      displayActionSuccess("Store cleared");
	   	      
	   	    };
	   	    req.onerror = function (evt) {
	   	      console.error("clearObjectStore:", evt.target.errorCode);
	   	   
	   	    };
	   	  }
	   	
	   	function adds(){
	   		
	   		var category = document.getElementById('category').value;
	   		
	   		var dt = new Date();
	   		
	   		
	   		var times = 0;
	   		times = parseInt(dt.getSeconds())
	   		times = times + (parseInt(dt.getMinutes())*60)
	   		times = times + (parseInt(dt.getHours())*60)*60
	   		
	   		
	   		//times = (times*0.00001).toFixed(5)
	   		
	   		times = minmax(times);
	   		
		    var store = getObjectStore(DB_STORE_NAME,'readwrite');
		    
		    req = store.add({times:times,category:category,etc:'00'});
		    
		    req.onsuccess = function (evt) {
		        console.log("Insertion in DB successful");
		        
		        timeArray = new Array; 	
		   	    categoryArray = new Array;
		   	    
		   	 	timeArray.push(times)
		   	 	categoryArray.push(category)
		   	 	
		   	 	
		   	 	const x = tf.tensor1d(timeArray,'float32');
	   	  	 	var X = x.reshape([timeArray.length, 1])
	   	 	 	var Y = tf.oneHot(tf.tensor1d(categoryArray, 'int32'), 10)
	   	 		initTF(X,Y,"")
		        
		      };
		      req.onerror = function() {
		        console.error("addPublication error", this.error);
		        displayActionFailure(this.error);
		      };
	   	}
	   		   	
	   	
	   	function lists(){
	   		store = getObjectStore(DB_STORE_NAME, 'readonly');
	   		//req = store.count();
	   		timeArray = new Array; 	
	   	    categoryArray = new Array;
	   		req = store.openCursor();
	   		
	   		var i = 0;
	   	    req.onsuccess = function(evt) {
	   	    	
	   	      var cursor = evt.target.result;
	   	      
	   	      // If the cursor is pointing at something, ask for the data
	   	      if (cursor) {
	   	        console.log("displayPubList cursor:", cursor);
	   	        req = store.get(cursor.key);
	   	        req.onsuccess = function (evt) {
	   	          var value = evt.target.result;
		   	       /* console.log("times :", value.times);
		   	  	   console.log("category :", value.category);
		   	  		console.log("etc :", value.etc); */
		   	  	timeArray.push(value.times);
		  	 	 categoryArray.push(value.category);
		   	  		
	   	        };
	   	        // Move on to the next object in store
	   	        cursor.continue();
	   	        // This counter serves only to create distinct ids
	   	   
	   	        
	   	      } else {
	   	       	//alert(timeArray);
	   	     	//alert(categoryArray);
	   	     	
	   	     const x = tf.tensor1d(timeArray,'float32');
	   	  	 var X = x.reshape([timeArray.length, 1])
	   	 	 var Y = tf.oneHot(tf.tensor1d(categoryArray, 'int32'), 10)
	   	 	initTF(X,Y,'init')
	   	  	 
	   	      }
	   	    
	   	      
	   	    };
	   		
	   	}
	   	
	   	async function initTF(X,Y,kind) {
	   		
	   		if (kind == "init"){
	   			
	   			const learningRate = 0.1;
	   			const optimizer = tf.train.sgd(learningRate);
	   			
	   			model = tf.sequential();
	   			model.add(tf.layers.dense({units: 1, batchInputShape: [null ,1]}));
			   	model.add(tf.layers.dense({units: 3, activation: 'relu'}));
			   	model.add(tf.layers.dense({units: 10, activation: 'softmax'}));
			   	model.compile({optimizer: optimizer, loss: 'categoricalCrossentropy'});
			   	const history = await model.fit(
			   			X, Y, {
			   	  batchSize: 10,
			   	  epochs:10,
			   	});
			   	
			   	
		   	    var pred = model.predict(tf.tensor1d(getTime(),'float32'));
		   	 	var rs = pred.as1D().argMax()
		   		document.getElementById('stext').value = resultVal(rs.arraySync());

		   	 	
		   	 	const result = model.evaluate(X, Y, {
			   	  batchSize: 10,
			   	});
			   	result.print();
		   	 	
		   	 	
		   	 	const saveResults = await model.save('indexeddb://category-model');
	   			
	   		}else{
	   			
	   			const model = await tf.loadLayersModel('indexeddb://category-model');
	   			model.compile({optimizer: 'sgd', loss: 'categoricalCrossentropy'});
	   			const history = await model.fit(
			   			X, Y, {
			   	  batchSize: 10,
			   	  epochs: 1,
			   	});
			   	
			   	const saveResults = await model.save('indexeddb://category-model');
	   		}
	   		
		   	
		   	
		   	 
	   	}
        
		   			
	   	async function getCategory(){
			
			try{
				const model = await tf.loadLayersModel('indexeddb://category-model');
				
				var dt = new Date();
				var times = 0;
		   		times = parseInt(dt.getSeconds())
		   		times = times + (parseInt(dt.getMinutes())*60)
		   		times = times + (parseInt(dt.getHours())*60)*60
		   		timeArray = new Array; 	
		   		timeArray.push(minmax(times))
				model.predict(tf.tensor1d(timeArray,'float32')).print();
				
			}catch(error){
				lists()
			}
		}
		
		
	   	async function testProc(){
		   	const loadedModel = await tf.loadLayersModel('indexeddb://category-model');
		   	console.log('Prediction from loaded model:');
		   	loadedModel.compile({optimizer: 'sgd', loss: 'categoricalCrossentropy'});
		   	
		   	const result = loadedModel.evaluate(tf.ones([1, 1]), tf.ones([1, 10]), {
		   	  batchSize: 10,
		   	});
		   	result.print();
		   	
		   	timeArray = new Array;
	   	 	timeArray.push(minmax(70000))
		   	loadedModel.predict(tf.tensor1d(timeArray,'float32')).print();
		
		}

	   	
	   	function minmax(val){
		   	 max_a = 86400
		     min_a = 1
		     min_norm = 0
		     max_norm = 1
		     return ((val - min_a) / (max_a-min_a)).toFixed(5)
	   	}
	   	
	   	
	   	function resultVal(val){
	   		var a = new Array('news','shopping','study','sports','job','movie','fishing','food','travel','game')
	   		return a[val];
	   		
	   	}
	   	
	   	
	   	function getTime(){
	   		
	   		var dt = new Date();
			var times = 0;
	   		times = parseInt(dt.getSeconds())
	   		times = times + (parseInt(dt.getMinutes())*60)
	   		times = times + (parseInt(dt.getHours())*60)*60
	   		timeArray = new Array; 	
	   		timeArray.push(minmax(times))
	   		
	   		return timeArray
	   	}
	   	
    </script>
</head>
<body>
 	<select id="category">
		<option value='0'>news</option>
		<option value='1'>shopping</option>
		<option value='2'>study</option>
		<option value='3'>sports</option>
		<option value='4'>job</option>
		<option value='5'>movie</option>
		<option value='6'>fishing</option>
		<option value='7'>food</option>
		<option value='8'>travel</option>
		<option value='9'>game</option>
 	</select>
 	
	<input type="text" id="stext" value="" />
	<input type="button" id="search" value="search" onclick="adds()"/>
    <input type="button" id="" value="list" onclick="lists()" />
     <input type="button" id="" value="getCategory" onclick="getCategory()"/>
     
     <input type="button" id="" value="testProc" onclick="testProc()" />
     
     <input type="button" id="" value="mix" onclick="mix()" />
      
</html>
